# Swagger generated server

Spring Boot Server 


## Overview  
This server was generated by the [swagger-codegen](https://github.com/swagger-api/swagger-codegen) project.  
By using the [OpenAPI-Spec](https://github.com/swagger-api/swagger-core), you can easily generate a server stub.  
This is an example of building a swagger-enabled server in Java using the SpringBoot framework.  

The underlying library integrating swagger to SpringBoot is [springfox](https://github.com/springfox/springfox)  

Start your server as an simple java application.

This project requires Java 1.8 and Maven 3

To build:
 
`mvn clean install`

To run: 

`mvn spring-boot:run`

or

`java -jar target/miguelmunoz.challenge-0.0.1-SNAPSHOT.jar`

## REST API Documentation

You can view the api documentation in swagger-ui by launching the server, then goint to 
`http://localhost:8080/NeptuneDreams/CustomerOrders/1.0.0/swagger-ui.html`

Change default port value in application.properties

## Database
You do not need to launch a database server to run this application. I use an embedded h2 database. This is great for demo purposes, because you don't need to launch a server, and it's a java database, so it runs with very little configuration.

## JPA Entities

### 1. MenuItem
A MenuItem consists of a name, price, and list of MenuItemOptions (below). The list consists of all possible options for this menu item. MenuItem has a One-to-Many relationship with MenuItemOption. It also includes a price.

### 2. MenuItemOption
A MenuItemOption adds an option to aMenuItem (below). It also has a delta price, which is the amount the price changes if the guest chooses this option.

### 3. CustomerOrder
A Food order is an actual order. It has a final price, a boolean to record when it has been completed and delivered, and an order date and completion date, and a list of MenuItemOptions. Unlike the MenuItem, the list of options is all the chosen options, rather than the available options. Also, unlike MenuItem, the CustomerOrder has a Many-To-Many relationship with MenuItemOption.

## Testing
The testing application properties specify a memory database, so changes get wiped out from test to test. This greatly facilitates testing.


-----

### Coding Questions

**_1. How have you scaled your Java based web applications in the past?_**

The most important task has often been to process high-demand tasks asynchronously. This doesn't work with all tasks, but should be applied wherever it works and is necessary. Careful attention to what data is cached and what caches are turned on is also helpful. 
 
**_2. What is a common OOP design pattern that you have used in your web applications in the past and why?_**

Most useful:

a. Observer/Broadcaster, which allows loose coupling. Lets the data model broadcast changes without knowing anything about who might be listening.

b. Inversion of Control. Reduces dependencies between classes, allowing the classes to be independent of each other, which also makes testing easier.

c. MVC. By separating the data model from the view, the data may be manipulated independently of anything else. Multiple Views listen for changes to the model. The Controller responds to user input, which lead it to make changes to the data model. Greatly simplifies the task of developing user interfaces.

d. Facade. Putting third-party libraries behind a facade is an excellent way to shield developers from the details of the library. This makes it easier to replace the library if a better solution is found. It also makes it easier to fix bugs in the developer's approach to the way the library is used.
 
**_3. How do you discover what is the root cause of a Java OutOfMemoryError?_**

a. Always look at the server log.

b. Use memory-leak features of profilers.

c. Use PhantomReferences to look for memory leaks.
 
**_4. What is your preferred method to perform parallel processing?_**

In Java 8, use a Spliterator. 
In Java 7 and before, use a Thread Pool and a Blocking Queue.
 
**_5. What is the normal unit test code coverage % of your web applications?_**

About 95%. I aim for 100%, but there are cases where the code can't be reached. For example, I may put in a statement to throw an exception in a case that can't be reached. I do this because future changes to the code may introduce bugs which make the exception reachable. My exception will reveal the new big immediately. The downside is that my exception code can't be executed by a unit test. A good illustration of this is a switch statement on an enum value. If I expect every case of the enum to get handled, I still put a default case, which throws an Exception with a message describing the enum value that was not handled. This way, if somebody adds an enum value with adding a case statement, the switch statement will throw an exception instead of silently failing.